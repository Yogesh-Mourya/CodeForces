// Alice and Bob are playing a game in which Alice has given Bob a positive integer x<108
// .

// To win the game, Bob has to find another positive integer y<109
//  such that x#y
//  is divisible by x+y
// .

// Here x#y
//  denotes the integer formed by concatenating the integers x
//  and y
//  in that order. For example, if x=835
// , y=47
// , then x#y=83547
// .

// However, since Bob is dumb, he is unable to find such an integer. Please help him.

// It can be shown that such an integer always exists.

// Input
// Each test contains multiple test cases. The first line contains the number of test cases t
//  (1≤t≤104
// ). The description of the test cases follows.

// The only line of each test case contains a single integer x
//  (1≤x<108
// ) — the integer that Alice has given to Bob.

// Output
// For each test case, print a single integer y
//  (1≤y<109
// ) so that Bob can win the game.

// If there are multiple answers, print any one of them.

// Example
// InputCopy
// 6
// 8
// 42
// 1000
// 66666
// 106344
// 9876543
// OutputCopy
// 1
// 12
// 998
// 7872
// 8190
// 174036
// Note
// For the first test case, x=8
// , we can choose y=1
// , and we have x#y=81
// , which is divisible by x+y=9
// .

// For the second test case, x=42
// , we can choose y=12
// , and we have x#y=4212
// , which is divisible by x+y=54
// .


#include <bits/stdc++.h>
using namespace std;

int EqualOrNot(int i, int j, int n, vector<int> &v) {
    int a = 0, b = 0, c = 0;

    a = v[i-1] % 3;
    b = (v[j-1] - v[i-1]) % 3;
    c = (v[n-1] - v[j-1]) % 3;

    if ((a == b && b == c) || (a != b && b != c && a != c))
        return 1;
    return 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;

    while (t--) {
        int x;
        cin >> x;
        
        cout << 2*x << "\n";
    }

    return 0;
}
